//######
//## TreeWidget.cpp
//## ==============
//## 07.04.2013: Creation
//## 02.06.2019: Version v2
//## 09.07.2022: Prise en compte QT57
//######

#include  "TreeWidget.h"

#include "I_ClosedFolder_16.xpm"
#include "I_NormalFile_16.xpm"

#define K_FN  0
#define K_CK  1
#define K_SZ  2
#define K_PN  3
#define K_ZZ  4
#define K_NN  5
#define K_CM  6
#define K_TYPE 7

//
// <<<< TreeWidget::TreeWidget
//
TreeWidget::TreeWidget( QWidget * p_Parent ): QTreeWidget( p_Parent )
{
  //-- Add Subdirectories as children  when user clicks on a file item,
  //-- otherwise adding all children recursively may consume HUGE amount of memory

  QTreeWidgetItem * HeaderItem = new QTreeWidgetItem();

  HeaderItem->setText( K_CK, QString( " "  ) );
  HeaderItem->setText( K_FN, QString( "File Name"   ) );
  HeaderItem->setText( K_SZ, QString( "Size (Bytes)") );
  HeaderItem->setText( K_PN, QString( "Path"        ) );
  //HeaderItem->setText( K_ZZ, QString( " "  ) );
  
  HeaderItem->setText( K_ZZ, QString( "Last Modification"        ) );
  HeaderItem->setText( K_NN, QString( "Taille Mo") );
  HeaderItem->setText( K_CM, QString( "Commentaire") );
  HeaderItem->setText(K_TYPE, QString("Type"));

  this->setHeaderItem( HeaderItem );

  this->setSortingEnabled( true );
  this->sortItems( 0, Qt::AscendingOrder );

  this->Adjust_ColumnSize();

  connect( this , SIGNAL( itemClicked     ( QTreeWidgetItem *, int ) )
         , this , SLOT  ( slot_itemClicked( QTreeWidgetItem *, int ) ) );

  connect( this , SIGNAL( currentItemChanged     ( QTreeWidgetItem *, QTreeWidgetItem * ) )
         , this , SLOT  ( slot_currentItemChanged( QTreeWidgetItem *, QTreeWidgetItem * ) ) );

}
// >>>> TreeWidget::TreeWidget


//
// <<<< TreeWidget::~TreeWidget
//
TreeWidget::~TreeWidget()
{
}
// >>>> TreeWidget::~TreeWidget


//
// <<<< TreeWidget::Add_FirstChild
//
void TreeWidget::Add_FirstChild( QString p_FilePath )
{
  QFileInfo fileInfo( p_FilePath );

  if ( fileInfo.isSymLink() ) {
    return;
  }

  QString FileName = fileInfo.fileName();

  QTreeWidgetItem * child = new QTreeWidgetItem();

  child->setCheckState( K_CK, Qt::Checked );
  child->setTextAlignment( K_CK, Qt::AlignCenter );

  child->setText( K_FN, fileInfo.fileName() );

  child->setIcon( K_FN, *( new QIcon( QPixmap( (const char **) I_ClosedFolder_16 ) ) ) );
  child->setText( K_PN, fileInfo.absoluteFilePath() );

  this->clear();
  this->addTopLevelItem( child );

  this->Add_Children( p_FilePath, child );

  child->setExpanded( true );

  this->Adjust_ColumnSize();
}
// >>>> TreeWidget::Add_FirstChild

qint64 TreeWidget::calculateDirectorySize(const QString &directoryPath) {
    qint64 totalSize = 0;
    QDir directory(directoryPath);
    QDir::Filters fileFilters = QDir::Files | QDir::NoSymLinks | QDir::Hidden;
    QDir::Filters dirFilters = QDir::Dirs | QDir::NoSymLinks | QDir::NoDotAndDotDot | QDir::Hidden;

    // Calculate total size of all files directly in the directory
    for (const QFileInfo &fileInfo : directory.entryInfoList(fileFilters, QDir::Name)) {
        totalSize += fileInfo.size();
    }

    // Recursively calculate size of all subdirectories
    for (const QFileInfo &dirInfo : directory.entryInfoList(dirFilters, QDir::Name)) {
        totalSize += calculateDirectorySize(dirInfo.absoluteFilePath());
    }

    return totalSize;
}


QString TreeWidget::formatSize(qint64 size) {
    static const QStringList sizeUnits = {"Bytes", "KB", "MB", "GB", "TB"};
    int unitIndex = 0;
    double displaySize = size;

    while (displaySize >= 1024 && unitIndex < sizeUnits.size() - 1) {
        displaySize /= 1024.0;
        ++unitIndex;
    }

    return QString::number(displaySize, 'f', 2) + " " + sizeUnits[unitIndex];
}



//
// <<<< TreeWidget::Add_Children
//
void TreeWidget::Add_Children(QString p_FilePath, QTreeWidgetItem * p_Item)
{
    if (p_Item && p_Item->childCount() != 0) return;

    QDir *DIR = new QDir(p_FilePath);
    QFileInfoList filesList = DIR->entryInfoList(QDir::NoDotAndDotDot | QDir::AllEntries | QDir::Hidden, QDir::DirsFirst);

    foreach (QFileInfo fileInfo, filesList) {
        if (fileInfo.isSymLink()) continue;

        QTreeWidgetItem *child = new QTreeWidgetItem();
        child->setCheckState(K_CK, Qt::Checked);
        child->setTextAlignment(K_CK, Qt::AlignCenter);
        child->setText(K_FN, fileInfo.fileName());

        if (fileInfo.isFile()) {
            child->setIcon(K_FN, QIcon(QPixmap((const char **)I_NormalFile_16)));
            child->setText(K_SZ, QString::number(fileInfo.size()));
            child->setTextAlignment(K_SZ, Qt::AlignRight);
            child->setText(K_NN, formatSize(fileInfo.size()));
            child->setText(K_ZZ, fileInfo.lastModified().toString("dd/MM/yyyy hh:mm"));
            child->setText(K_TYPE, fileType(fileInfo));
        }

        if (fileInfo.isDir()) {
            qint64 dirSize = calculateDirectorySize(fileInfo.absoluteFilePath());
            child->setIcon(K_FN, QIcon(QPixmap((const char **)I_ClosedFolder_16)));
            child->setText(K_PN, fileInfo.absoluteFilePath());
            child->setText(K_NN, formatSize(dirSize));
            child->setText(K_ZZ, fileInfo.lastModified().toString("dd/MM/yyyy hh:mm"));
            child->setText(K_TYPE, "Folder");
        }

        child->setText(K_CM, ""); 
        child->setFlags(child->flags() | Qt::ItemIsEditable);

        if (p_Item == nullptr) {
            this->addTopLevelItem(child);
        } else {
            p_Item->addChild(child);
        }
    }

    delete DIR;
}

// >>>> TreeWidget::Add_Children

QString TreeWidget::fileType(const QFileInfo &fileInfo) {
    if (fileInfo.isDir()) {
        return "Folder";
    }

    // Extract the file extension
    QString extension = fileInfo.suffix().toLower();

    // Map of file extensions to more descriptive types
    static const QMap<QString, QString> extensionDescriptions = {
        // Programming and scripting languages
        {"cpp", "C++ Source File"},
        {"c", "C Source File"},
        {"h", "C/C++ Header File"},
        {"hpp", "C++ Header File"},
        {"py", "Python Script"},
        {"java", "Java Source File"},
        {"js", "JavaScript File"},
        {"ts", "TypeScript File"},
        {"php", "PHP Script"},
        {"rb", "Ruby Script"},
        {"swift", "Swift Source File"},
        {"go", "Go Source File"},

        // Markup and stylesheets
        {"html", "HTML Document"},
        {"htm", "HTML Document"},
        {"css", "CSS Style Sheet"},
        {"scss", "Sass CSS File"},
        {"sass", "Sass File"},
        {"xml", "XML Document"},
        {"json", "JSON File"},

        // Document formats
        {"pdf", "PDF Document"},
        {"doc", "Microsoft Word Document"},
        {"docx", "Microsoft Word Document"},
        {"ppt", "Microsoft PowerPoint Presentation"},
        {"pptx", "Microsoft PowerPoint Presentation"},
        {"xls", "Microsoft Excel Spreadsheet"},
        {"xlsx", "Microsoft Excel Spreadsheet"},
        {"txt", "Text File"},
        {"md", "Markdown File"},

        // Image formats
        {"jpg", "JPEG Image"},
        {"jpeg", "JPEG Image"},
        {"png", "PNG Image"},
        {"gif", "GIF Image"},
        {"bmp", "Bitmap Image"},
        {"svg", "SVG Vector Image"},

        // Audio and video formats
        {"mp3", "MP3 Audio"},
        {"wav", "WAV Audio"},
        {"mp4", "MP4 Video"},
        {"avi", "AVI Video"},
        {"mov", "QuickTime Movie"},
        {"mkv", "MKV Video"},

        // Archive formats
        {"zip", "ZIP Archive"},
        {"rar", "RAR Archive"},
        {"7z", "7z Archive"},
        {"gz", "Gzip Compressed Archive"},
        {"tar", "Tarball Archive"}
    };

    return extensionDescriptions.value(extension, "File");
}


//
// <<<< TreeWidget::Adjust_ColumnSize
//
void TreeWidget::Adjust_ColumnSize()
{
  this->resizeColumnToContents( K_FN );
  this->resizeColumnToContents( K_CK );
  this->resizeColumnToContents( K_SZ );
  this->resizeColumnToContents( K_PN );
  this->resizeColumnToContents( K_ZZ );
  this->resizeColumnToContents( K_NN );
  this->resizeColumnToContents( K_CM );
  this->resizeColumnToContents( K_TYPE );

  this->update();

  int Size_PN = this->columnWidth( K_PN );
  int Size_ZZ = this->columnWidth( K_ZZ );

  int MaxSize = 1;

  if ( Size_ZZ > MaxSize ) {
    Size_PN = Size_PN + Size_ZZ  - MaxSize;
    Size_ZZ = MaxSize;
  }

  this->setColumnWidth( K_PN, Size_PN );
  this->setColumnWidth( K_ZZ, Size_ZZ );
}
// >>>> TreeWidget::Adjust_ColumnSize


//
// <<<< TreeWidget::Get_PathName
//
QString TreeWidget::Get_PathName( QTreeWidgetItem* p_Item )
{
  if ( ! p_Item ) {
    return "";
  }

  QString FileName = p_Item->text( K_FN );
  QString PathName = p_Item->text( K_PN );

  if ( FileName.isEmpty() ) {
    return "";
  }

  if ( PathName.isEmpty() ) {
    QTreeWidgetItem * p_Parent = p_Item->parent();

    PathName = p_Parent->text( K_PN ) + QString( "/" ) + FileName;
  }

  return PathName;
}
// >>>> TreeWidget::Get_PathName


void TreeWidget::dragEnterEvent(QDragEnterEvent *event) {
    if (event->mimeData()->hasFormat("text/uri-list")) {
        event->acceptProposedAction();
    }
}

void TreeWidget::dragMoveEvent(QDragMoveEvent *event) {
    event->acceptProposedAction();
}

void TreeWidget::dropEvent(QDropEvent *event) {
    if (event->mimeData()->hasUrls()) {
        foreach (const QUrl &url, event->mimeData()->urls()) {
            QString localPath = url.toLocalFile();
            qDebug() << "Dropped file path:" << localPath;
            // You can add a new item or handle the drop based on your application's logic
        }
        event->acceptProposedAction();
    }
}




Qt::DropActions TreeWidget::supportedDropActions() const {
    return Qt::CopyAction | Qt::MoveAction; // Ensure this reflects your application's capabilities
}



QStringList TreeWidget::mimeTypes() const {
    return QStringList() << "text/uri-list";
}



//
// <<<< TreeWidget::keyPressEvent
//
void TreeWidget::keyPressEvent( QKeyEvent * p_Event )
{
  bool b_IGNORE = false;

  QTreeWidgetItem * qItem = this->currentItem();
  
  

  switch ( p_Event->key() ) {
  case Qt::Key_Space:

    if ( qItem ) {
      bool b_WasChecked = ( qItem->checkState( K_CK ) == Qt::Checked );
      
      if ( b_WasChecked ) {

        qItem->setCheckState( K_CK, Qt::Unchecked );

        for( int i = 0; i < qItem->childCount(); i++ ) {

          qItem->child( i )->setCheckState( K_CK, Qt::Unchecked );

        }

      } else {

        qItem->setCheckState( K_CK, Qt::Checked );

        for( int i = 0; i < qItem->childCount(); i++ ) {

          qItem->child( i )->setCheckState( K_CK, Qt::Checked );

        }

      }

      if ( b_WasChecked ) {
        qItem->setCheckState( K_CK, Qt::Unchecked );
      } else {
        qItem->setCheckState( K_CK, Qt::Checked );
      }
    }

    b_IGNORE = true;

    break;

  case Qt::Key_F5:
    this->Adjust_ColumnSize();
    break;

  default:
    break;
  }

  if ( b_IGNORE ) {
    p_Event->ignore();
  } else {
    QTreeView::keyPressEvent( p_Event );
  }
}
// >>>> TreeWidget::keyPressEvent


//
// <<<< TreeWidget::mousePressEvent
//
void TreeWidget::mousePressEvent( QMouseEvent* p_Event )
{
  QPoint            qPoint;
  QTreeWidgetItem * qItem;

  if ( p_Event->button() == Qt::LeftButton ) {

#ifdef QT57
    qPoint = QPoint( p_Event->x(), p_Event->y() );
#else
    qPoint = p_Event->pos();
#endif

    qItem  = (QTreeWidgetItem * ) this->itemAt( qPoint );

    int k_Column;

    if ( qItem ) {
      k_Column = this->columnAt( qPoint.x() );

      if ( k_Column > 0 ) {
        p_Event->accept();
      }
    }
    Qt::CheckState newState = (qItem->checkState(K_CK) == Qt::Checked) ? Qt::Unchecked : Qt::Checked;
    qItem->setCheckState(K_CK, newState);
    for(int i = 0; i < qItem->childCount(); i++) {
        qItem->child(i)->setCheckState(K_CK, newState);
    }
  }

  if ( p_Event->button() == Qt::RightButton ) {

#ifdef QT57
    qPoint = QPoint( p_Event->x(), p_Event->y() );
#else
    qPoint = p_Event->pos();
#endif

    QTreeWidgetItem * qItem = this->itemAt( qPoint );

    int k_Column;

    k_Column = this->columnAt( qPoint.x() );  // Coordonnees relatives

    emit SIGNAL_RightClicked( qItem, k_Column ); // qItem peut etre NULL

    p_Event->accept();
  }

  QTreeWidget::mousePressEvent( p_Event );
}
// >>>> TreeWidget::mousePressEvent


//
// <<<< TreeWidget::slot_itemClicked
//
void TreeWidget::slot_itemClicked( QTreeWidgetItem* p_Item, int /*p_Column*/ )
{
  QString FilePath = p_Item->text( K_PN );

  if ( FilePath.isEmpty() ) return;

  QFileInfo FI_Path( FilePath );

  if ( FI_Path.isSymLink() ) return;
  if ( FI_Path.isFile()    ) return;

  this->Add_Children( FilePath, p_Item );

  this->Adjust_ColumnSize();
}
// >>>> TreeWidget::slot_itemClicked


//
// <<<< TreeWidget::slot_currentItemChanged
//
void TreeWidget::slot_currentItemChanged( QTreeWidgetItem * p_Current
                                        , QTreeWidgetItem * /* p_Previous  */ )
{
  QString PathName = this->Get_PathName( p_Current );

  if ( ! PathName.isEmpty() ) {
    emit SIGNAL_Statut_Fichier( PathName );
  }
}
// >>>> TreeWidget::slot_currentItemChanged 
